gcc -no-pie -o run $(OBJECT)

gcc -o Q3 Q3.c -lpthread
#gcc -pthread -o Q1 Q1.c

gcc -O3 -march=native -o q6 q6.c -L${MKLROOT}/lib/intel64 -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread -lm -ldl

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "mkl.h"

int main()
{
    int n = 2048; // problem size
    double *x, *y;
    double a = 2.0;
    double time_spent;
    double gflops;

    // allocate memory for input vectors
    x = (double*) malloc(n * sizeof(double));
    y = (double*) malloc(n * sizeof(double));

    // generate input vectors using double precision random values
    srand(time(NULL));
    for (int i = 0; i < n; i++) {
        x[i] = drand48();
        y[i] = drand48();
    }

    // measure time and performance for cblas_daxpy routine
    clock_t begin = clock();
    cblas_daxpy(n, a, x, 1, y, 1);
    clock_t end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    gflops = (double)(2 * n) / (time_spent * 1e9);

    // print results
    printf("Problem Size: %d\n", n);
    printf("Time: %f ms\n", time_spent * 1000);
    printf("GFlops/s: %f\n", gflops);

    // free memory
    free(x);
    free(y);

    n = 5120; // problem size

    // allocate memory for input vectors
    x = (double*) malloc(n * sizeof(double));
    y = (double*) malloc(n * sizeof(double));

    // generate input vectors using double precision random values
    srand(time(NULL));
    for (int i = 0; i < n; i++) {
        x[i] = drand48();
        y[i] = drand48();
    }

    // measure time and performance for cblas_daxpy routine
    begin = clock();
    cblas_daxpy(n, a, x, 1, y, 1);
    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    gflops = (double)(2 * n) / (time_spent * 1e9);

    // print results
    printf("Problem Size: %d\n", n);
    printf("Time: %f ms\n", time_spent * 1000);
    printf("GFlops/s: %f\n", gflops);

    // free memory
    free(x);
    free(y);
    return 0;
}

gcc -O3 -march=native -o q6 q6.c -L${MKLROOT}/lib/intel64 -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread -lm -ldl

./q6

gcc -pthread q8.c -o q8
./q8


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define VECTOR_SIZE 10000000
#define NUM_THREADS 4

int* vector_a;
int* vector_b;
int* vector_c;

void* vector_addition(void* args) {
    int thread_id = *(int*)args;
    int block_size = VECTOR_SIZE / NUM_THREADS;
    int start = thread_id * block_size;
    int end = start + block_size;

    for (int i = start; i < end; i++) {
        vector_c[i] = vector_a[i] + vector_b[i];
    }

    pthread_exit(NULL);
}

int main() {
    // Allocate memory for vectors
    vector_a = malloc(VECTOR_SIZE * sizeof(int));
    vector_b = malloc(VECTOR_SIZE * sizeof(int));
    vector_c = malloc(VECTOR_SIZE * sizeof(int));

    // Initialize vectors with random values
    for (int i = 0; i < VECTOR_SIZE; i++) {
        vector_a[i] = rand() % 100;
        vector_b[i] = rand() % 100;
    }

    // Create threads
    pthread_t threads[NUM_THREADS];
    int thread_args[NUM_THREADS];

    for (int i = 0; i < NUM_THREADS; i++) {
        thread_args[i] = i;
        pthread_create(&threads[i], NULL, vector_addition, (void*)&thread_args[i]);
    }

    // Join threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Print result
    printf("Vector addition result:\n");
    for (int i = 0; i < VECTOR_SIZE; i++) {
        printf("%d ", vector_c[i]);
    }
    printf("\n");

    // Free memory
    free(vector_a);
    free(vector_b);
    free(vector_c);

    return 0;
}

nasm -f elf64 q2.asm
gcc -no-pie -o run q2.o















